// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: play4good.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addUserToTeam = `-- name: AddUserToTeam :one
INSERT INTO user_team (user_id, team_id, role)
VALUES ($1, $2, $3)
RETURNING user_id, team_id, role
`

type AddUserToTeamParams struct {
	UserID int32  `json:"user_id"`
	TeamID int32  `json:"team_id"`
	Role   string `json:"role"`
}

func (q *Queries) AddUserToTeam(ctx context.Context, arg AddUserToTeamParams) (UserTeam, error) {
	row := q.queryRow(ctx, q.addUserToTeamStmt, addUserToTeam, arg.UserID, arg.TeamID, arg.Role)
	var i UserTeam
	err := row.Scan(&i.UserID, &i.TeamID, &i.Role)
	return i, err
}

const createCause = `-- name: CreateCause :one
INSERT INTO causes (name, description, goal, start_date, end_date, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, description, goal, current_amount, start_date, end_date, status, created_at, updated_at
`

type CreateCauseParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Goal        sql.NullString `json:"goal"`
	StartDate   sql.NullTime   `json:"start_date"`
	EndDate     sql.NullTime   `json:"end_date"`
	Status      sql.NullString `json:"status"`
}

func (q *Queries) CreateCause(ctx context.Context, arg CreateCauseParams) (Cause, error) {
	row := q.queryRow(ctx, q.createCauseStmt, createCause,
		arg.Name,
		arg.Description,
		arg.Goal,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
	)
	var i Cause
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Goal,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDonation = `-- name: CreateDonation :one
INSERT INTO donations (user_id, cause_id, team_id, amount, donation_type, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, cause_id, team_id, amount, donation_type, status, created_at
`

type CreateDonationParams struct {
	UserID       sql.NullInt32  `json:"user_id"`
	CauseID      sql.NullInt32  `json:"cause_id"`
	TeamID       sql.NullInt32  `json:"team_id"`
	Amount       sql.NullString `json:"amount"`
	DonationType sql.NullString `json:"donation_type"`
	Status       sql.NullString `json:"status"`
}

func (q *Queries) CreateDonation(ctx context.Context, arg CreateDonationParams) (Donation, error) {
	row := q.queryRow(ctx, q.createDonationStmt, createDonation,
		arg.UserID,
		arg.CauseID,
		arg.TeamID,
		arg.Amount,
		arg.DonationType,
		arg.Status,
	)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CauseID,
		&i.TeamID,
		&i.Amount,
		&i.DonationType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createLeaderboard = `-- name: CreateLeaderboard :one
INSERT INTO leaderboards (name, type, start_date, end_date)
VALUES ($1, $2, $3, $4)
RETURNING id, name, type, start_date, end_date
`

type CreateLeaderboardParams struct {
	Name      string         `json:"name"`
	Type      sql.NullString `json:"type"`
	StartDate sql.NullTime   `json:"start_date"`
	EndDate   sql.NullTime   `json:"end_date"`
}

func (q *Queries) CreateLeaderboard(ctx context.Context, arg CreateLeaderboardParams) (Leaderboard, error) {
	row := q.queryRow(ctx, q.createLeaderboardStmt, createLeaderboard,
		arg.Name,
		arg.Type,
		arg.StartDate,
		arg.EndDate,
	)
	var i Leaderboard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (name, description, avatar_url)
VALUES ($1, $2, $3)
RETURNING id, name, description, avatar_url, created_at, updated_at
`

type CreateTeamParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.queryRow(ctx, q.createTeamStmt, createTeam, arg.Name, arg.Description, arg.AvatarUrl)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_hash, first_name, last_name, avatar_url)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, username, email, password_hash, first_name, last_name, avatar_url, created_at, updated_at
`

type CreateUserParams struct {
	Username     string         `json:"username"`
	Email        string         `json:"email"`
	PasswordHash string         `json:"password_hash"`
	FirstName    sql.NullString `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	AvatarUrl    sql.NullString `json:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserToken = `-- name: CreateUserToken :one
INSERT INTO user_tokens (user_id, token, expiry)
VALUES ($1, $2, $3)
RETURNING id, user_id, token, expiry, created_at, updated_at
`

type CreateUserTokenParams struct {
	UserID sql.NullInt32 `json:"user_id"`
	Token  string        `json:"token"`
	Expiry time.Time     `json:"expiry"`
}

func (q *Queries) CreateUserToken(ctx context.Context, arg CreateUserTokenParams) (UserToken, error) {
	row := q.queryRow(ctx, q.createUserTokenStmt, createUserToken, arg.UserID, arg.Token, arg.Expiry)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Expiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCause = `-- name: DeleteCause :exec
DELETE FROM causes
WHERE id = $1
`

func (q *Queries) DeleteCause(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteCauseStmt, deleteCause, id)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM user_tokens
WHERE expiry < now()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteExpiredTokensStmt, deleteExpiredTokens)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE id = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteTeamStmt, deleteTeam, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, id)
	return err
}

const deleteUserToken = `-- name: DeleteUserToken :exec
DELETE FROM user_tokens
WHERE user_id = $1
AND token = $2
`

type DeleteUserTokenParams struct {
	UserID sql.NullInt32 `json:"user_id"`
	Token  string        `json:"token"`
}

func (q *Queries) DeleteUserToken(ctx context.Context, arg DeleteUserTokenParams) error {
	_, err := q.exec(ctx, q.deleteUserTokenStmt, deleteUserToken, arg.UserID, arg.Token)
	return err
}

const getCause = `-- name: GetCause :one
SELECT id, name, description, goal, current_amount, start_date, end_date, status, created_at, updated_at FROM causes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCause(ctx context.Context, id int32) (Cause, error) {
	row := q.queryRow(ctx, q.getCauseStmt, getCause, id)
	var i Cause
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Goal,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDonation = `-- name: GetDonation :one
SELECT id, user_id, cause_id, team_id, amount, donation_type, status, created_at FROM donations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDonation(ctx context.Context, id int32) (Donation, error) {
	row := q.queryRow(ctx, q.getDonationStmt, getDonation, id)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CauseID,
		&i.TeamID,
		&i.Amount,
		&i.DonationType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getLeaderboard = `-- name: GetLeaderboard :one
SELECT id, name, type, start_date, end_date FROM leaderboards
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLeaderboard(ctx context.Context, id int32) (Leaderboard, error) {
	row := q.queryRow(ctx, q.getLeaderboardStmt, getLeaderboard, id)
	var i Leaderboard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getLeaderboardEntries = `-- name: GetLeaderboardEntries :many
SELECT leaderboard_id, user_id, team_id, score, rank FROM leaderboard_entries
WHERE leaderboard_id = $1
ORDER BY rank
LIMIT $2 OFFSET $3
`

type GetLeaderboardEntriesParams struct {
	LeaderboardID int32 `json:"leaderboard_id"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

func (q *Queries) GetLeaderboardEntries(ctx context.Context, arg GetLeaderboardEntriesParams) ([]LeaderboardEntry, error) {
	rows, err := q.query(ctx, q.getLeaderboardEntriesStmt, getLeaderboardEntries, arg.LeaderboardID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LeaderboardEntry{}
	for rows.Next() {
		var i LeaderboardEntry
		if err := rows.Scan(
			&i.LeaderboardID,
			&i.UserID,
			&i.TeamID,
			&i.Score,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
SELECT id, name, description, avatar_url, created_at, updated_at FROM teams
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTeam(ctx context.Context, id int32) (Team, error) {
	row := q.queryRow(ctx, q.getTeamStmt, getTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, email, password_hash, first_name, last_name, avatar_url, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, first_name, last_name, avatar_url, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTokenByToken = `-- name: GetUserTokenByToken :one
SELECT id, user_id, token, expiry, created_at, updated_at
FROM user_tokens
WHERE token = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserTokenByToken(ctx context.Context, token string) (UserToken, error) {
	row := q.queryRow(ctx, q.getUserTokenByTokenStmt, getUserTokenByToken, token)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Expiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTokenByUserID = `-- name: GetUserTokenByUserID :one
SELECT id, user_id, token, expiry, created_at, updated_at
FROM user_tokens
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserTokenByUserID(ctx context.Context, userID sql.NullInt32) (UserToken, error) {
	row := q.queryRow(ctx, q.getUserTokenByUserIDStmt, getUserTokenByUserID, userID)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Expiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCauses = `-- name: ListCauses :many
SELECT id, name, description, goal, current_amount, start_date, end_date, status, created_at, updated_at FROM causes
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListCausesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCauses(ctx context.Context, arg ListCausesParams) ([]Cause, error) {
	rows, err := q.query(ctx, q.listCausesStmt, listCauses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cause{}
	for rows.Next() {
		var i Cause
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Goal,
			&i.CurrentAmount,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDonations = `-- name: ListDonations :many
SELECT id, user_id, cause_id, team_id, amount, donation_type, status, created_at FROM donations
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListDonationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDonations(ctx context.Context, arg ListDonationsParams) ([]Donation, error) {
	rows, err := q.query(ctx, q.listDonationsStmt, listDonations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Donation{}
	for rows.Next() {
		var i Donation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CauseID,
			&i.TeamID,
			&i.Amount,
			&i.DonationType,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaderboards = `-- name: ListLeaderboards :many
SELECT id, name, type, start_date, end_date FROM leaderboards
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListLeaderboardsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLeaderboards(ctx context.Context, arg ListLeaderboardsParams) ([]Leaderboard, error) {
	rows, err := q.query(ctx, q.listLeaderboardsStmt, listLeaderboards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Leaderboard{}
	for rows.Next() {
		var i Leaderboard
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, description, avatar_url, created_at, updated_at FROM teams
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListTeamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTeams(ctx context.Context, arg ListTeamsParams) ([]Team, error) {
	rows, err := q.query(ctx, q.listTeamsStmt, listTeams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password_hash, first_name, last_name, avatar_url, created_at, updated_at FROM users
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromTeam = `-- name: RemoveUserFromTeam :exec
DELETE FROM user_team
WHERE user_id = $1 AND team_id = $2
`

type RemoveUserFromTeamParams struct {
	UserID int32 `json:"user_id"`
	TeamID int32 `json:"team_id"`
}

func (q *Queries) RemoveUserFromTeam(ctx context.Context, arg RemoveUserFromTeamParams) error {
	_, err := q.exec(ctx, q.removeUserFromTeamStmt, removeUserFromTeam, arg.UserID, arg.TeamID)
	return err
}

const updateCause = `-- name: UpdateCause :one
UPDATE causes
SET name = $2, description = $3, goal = $4, current_amount = $5, start_date = $6, end_date = $7, status = $8, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, goal, current_amount, start_date, end_date, status, created_at, updated_at
`

type UpdateCauseParams struct {
	ID            int32          `json:"id"`
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	Goal          sql.NullString `json:"goal"`
	CurrentAmount sql.NullString `json:"current_amount"`
	StartDate     sql.NullTime   `json:"start_date"`
	EndDate       sql.NullTime   `json:"end_date"`
	Status        sql.NullString `json:"status"`
}

func (q *Queries) UpdateCause(ctx context.Context, arg UpdateCauseParams) (Cause, error) {
	row := q.queryRow(ctx, q.updateCauseStmt, updateCause,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Goal,
		arg.CurrentAmount,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
	)
	var i Cause
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Goal,
		&i.CurrentAmount,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDonationStatus = `-- name: UpdateDonationStatus :one
UPDATE donations
SET status = $2
WHERE id = $1
RETURNING id, user_id, cause_id, team_id, amount, donation_type, status, created_at
`

type UpdateDonationStatusParams struct {
	ID     int32          `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateDonationStatus(ctx context.Context, arg UpdateDonationStatusParams) (Donation, error) {
	row := q.queryRow(ctx, q.updateDonationStatusStmt, updateDonationStatus, arg.ID, arg.Status)
	var i Donation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CauseID,
		&i.TeamID,
		&i.Amount,
		&i.DonationType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateLeaderboardEntry = `-- name: UpdateLeaderboardEntry :one
INSERT INTO leaderboard_entries (leaderboard_id, user_id, team_id, score, rank)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (leaderboard_id, user_id, team_id) DO UPDATE
SET score = EXCLUDED.score, rank = EXCLUDED.rank
RETURNING leaderboard_id, user_id, team_id, score, rank
`

type UpdateLeaderboardEntryParams struct {
	LeaderboardID int32          `json:"leaderboard_id"`
	UserID        int32          `json:"user_id"`
	TeamID        int32          `json:"team_id"`
	Score         sql.NullString `json:"score"`
	Rank          sql.NullInt32  `json:"rank"`
}

func (q *Queries) UpdateLeaderboardEntry(ctx context.Context, arg UpdateLeaderboardEntryParams) (LeaderboardEntry, error) {
	row := q.queryRow(ctx, q.updateLeaderboardEntryStmt, updateLeaderboardEntry,
		arg.LeaderboardID,
		arg.UserID,
		arg.TeamID,
		arg.Score,
		arg.Rank,
	)
	var i LeaderboardEntry
	err := row.Scan(
		&i.LeaderboardID,
		&i.UserID,
		&i.TeamID,
		&i.Score,
		&i.Rank,
	)
	return i, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET name = $2, description = $3, avatar_url = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, avatar_url, created_at, updated_at
`

type UpdateTeamParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.queryRow(ctx, q.updateTeamStmt, updateTeam,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.AvatarUrl,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2, email = $3, first_name = $4, last_name = $5, avatar_url = $6, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, username, email, password_hash, first_name, last_name, avatar_url, created_at, updated_at
`

type UpdateUserParams struct {
	ID        int32          `json:"id"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	AvatarUrl sql.NullString `json:"avatar_url"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.queryRow(ctx, q.updateUserStmt, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserTeamRole = `-- name: UpdateUserTeamRole :one
UPDATE user_team
SET role = $3
WHERE user_id = $1 AND team_id = $2
RETURNING user_id, team_id, role
`

type UpdateUserTeamRoleParams struct {
	UserID int32  `json:"user_id"`
	TeamID int32  `json:"team_id"`
	Role   string `json:"role"`
}

func (q *Queries) UpdateUserTeamRole(ctx context.Context, arg UpdateUserTeamRoleParams) (UserTeam, error) {
	row := q.queryRow(ctx, q.updateUserTeamRoleStmt, updateUserTeamRole, arg.UserID, arg.TeamID, arg.Role)
	var i UserTeam
	err := row.Scan(&i.UserID, &i.TeamID, &i.Role)
	return i, err
}
